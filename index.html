<!doctype html>

<p><head>
<link rel="stylesheet" type="text/css" href="main.css">
</head></p>
<body>

<p><span>
<div id="wrapper" markdown="1"></p>
<h1 id="jsio">js.io</h1>
<h2>Table of Contents</h2>

<div class="toc">
<ul>
<li><a href="#jsio">js.io</a><ul>
<li><a href="#introducing-jsio">Introducing js.io</a></li>
<li><a href="#getting-started">Getting Started</a></li>
<li><a href="#simple-networking-io">Simple Networking I/O</a></li>
<li><a href="#chat-client-and-server">Chat Client and Server</a></li>
<li><a href="#modules-in-depth">Modules in Depth</a></li>
<li><a href="#utility">Utility</a><ul>
<li><a href="#class">Class</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p><span>
<div id="content" markdown="1"></p>
<h2 id="introducing-jsio">Introducing js.io</h2>
<p>The core of js.io is a simple module system that works in both web browsers and server-side JavaScript.  It is inspired by Python and CommonJS (as implemented in <a href="http://nodejs.org">node.js</a>).<br />
</p>
<h2 id="getting-started">Getting Started</h2>
<p><span class="comment">
If you're familiar with git, you could instead try the latest code from <a href="https://www.github.com/mcarter/js.io/">github</a>.
</span></p>
<p>Download a js.io release and extract it into your project and copy/symlink the packages folder into your project).<br />
</p>
<p>To import a module, use the function <code>jsio</code>.  This function takes 1 argument: the module identifier.  To load a module in file <code>util/myModule.js</code>, you would write <code>jsio('.util.myModule);</code>.  The '.' before <code>util</code> indicates that the file path is relative to where the current module is.<br />
</p>
<p><span class="comment">
Tip: try not to use global variables in a module.  Advanced JavaScripters will note that in js.io, <code>exports</code> is not necessarily an object.  Module authors could, for example, assign exports to a single function or class.
</span></p>
<p>Inside <code>util/myModule.js</code>, define local variables and functions.  The external interface to the module is defined using the <code>exports</code> object.  The object <code>exports</code> is available immediately in the module, so you can export a function by simply writing:</p>
<div class="codehilite"><pre><ol>
	<li>exports.logHello = function() { console.log('hello'); };</li>
</ol></pre></div>


<p>After we import the module with <code>jsio('.util.myModule');</code>, we can call <code>foo</code> immediately with <code>util.myModule.logHello()</code>.</p>
<h2 id="simple-networking-io">Simple Networking I/O</h2>
<p><span class="comment">
js.io's comet implementation conforms to the Comet Session Protocol (CSP) specification.  That specification arose from years of production use of Orbited through version 0.7.  Orbited 0.8 switched its internal network transports in favor of js.io's implementation of CSP.
</span></p>
<p>Js.io ships with a robust network protocol for real-time communication between web browsers and servers.  Though other implementations of 'comet' exist, js.io is specifically designed for handling stubborn proxies, old web browsers, and cross-domain communication, ensuring the stability and connectivity in <em>all</em> environments.  (In fact, you may even want to use js.io just for the network IO, in which case you can use a pre-compiled CSP client/server package.)</p>
<h2 id="chat-client-and-server">Chat Client and Server</h2>
<p>Let's build a chat client and server.  We'll use the Real Time JSON Protocol (RTJP) to abstract the network streams into events.  Rather than read and write directly to a socket, we'll send and receive frames with names and JSON payloads.  On the server side, we inherit from <code>RTJP</code> to create a class for client connections.  The <code>frameReceived</code> function is called when the client calls <code>client.sendFrame(frameName, args)</code>.</p>
<div class="codehilite"><pre><ol>
	<li>require('js.io');</li>
	<li>jsio.install();</li>
	<li>jsio('import net.interfaces');</li>
	<li>jsio('import net.protocols.rtjp as rtjp');</li>
	<li></li>
	<li>// one ClientConn is created for each client that connects</li>
	<li>var ClientConn = Class(rtjp.RTJPProtocol, function(supr) {</li>
	<li></li>
	<li>&nbsp; &nbsp; this.init = function(server){</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; this.server = server;</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; supr(this,'init',[]);</li>
	<li>&nbsp; &nbsp; }</li>
	<li></li>
	<li>&nbsp; &nbsp; this.connectionMade = function() {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; this.server.addConn(this);</li>
	<li>&nbsp; &nbsp; }</li>
	<li></li>
	<li>&nbsp; &nbsp; this.connectionLost = function() {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; this.server.removeConn(this);</li>
	<li>&nbsp; &nbsp; }</li>
	<li></li>
	<li>&nbsp; &nbsp; this.frameReceived = function(id, frameName, args) {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; logger.log('recieved frame', id, frameName, args);</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; switch(frameName) {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'JOIN':</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.server.broadcast('JOIN', {name: args.name, time: +new Date()});</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'MESSAGE':</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.server.broadcast('MESSAGE', args);</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; }</li>
	<li>&nbsp; &nbsp; }</li>
	<li>});</li>
	<li></li>
	<li>// only one of these is created</li>
	<li>var Server = Class(net.interfaces.Server, function() {</li>
	<li>&nbsp; &nbsp; this.init = function() {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; this._conns = [];</li>
	<li>&nbsp; &nbsp; }</li>
	<li>&nbsp; &nbsp; this.buildProtocol = function() { return new ClientConn(this); }</li>
	<li></li>
	<li>&nbsp; &nbsp; this.addConn = function(conn) { this._conns.push(conn); }</li>
	<li>&nbsp; &nbsp; this.removeConn = function(conn) { this._conns.filter(function(c) { return c != conn; }); }</li>
	<li></li>
	<li>&nbsp; &nbsp; this.broadcast = function(frameName, args) {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; for (var i = 0, conn; conn = this._conns[i]; i++) {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conn.sendFrame(frameName, args);</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; }</li>
	<li>&nbsp; &nbsp; }</li>
	<li>});</li>
	<li></li>
	<li>var server = new Server().listen('csp',{host:'localhost', port: 8000});</li>
</ol></pre></div>


<p>A corresponding browser client would look very similar:</p>
<div class="codehilite"><pre><ol>
	<li>jsio('import net');</li>
	<li>jsio('import net.protocols.rtjp as rtjp');</li>
	<li></li>
	<li>var Connection = Class(rtjp.RTJPProtocol, function() {</li>
	<li>&nbsp; &nbsp; this.frameReceived = function(id, frameName, args) {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; switch(frameName) {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'JOIN':</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logger.log('A chatter joined!', args.name, 'at time', args.time)</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 'MESSAGE':</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logger.log('Chatter says', args.name, ':', args.message)</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</li>
	<li>&nbsp; &nbsp; };</li>
	<li></li>
	<li>&nbsp; &nbsp; this.sendMessage = function(msg) {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; this.sendFrame('MESSAGE',{name: 'bob', message: msg});</li>
	<li>&nbsp; &nbsp; };</li>
	<li>});</li>
	<li></li>
	<li>var client = new Connection();</li>
	<li>net.connect(client, 'csp', {url: 'http://path/to/server:8001'});</li>
</ol></pre></div>


<h2 id="modules-in-depth">Modules in Depth</h2>
<p>Each JavaScript file is a module.  To identify a module, we use the file path to the JavaScript file.  Dots (<code>.</code>) in the module identifier separate folder names and filenames.  There are two types of identifiers: absolute identifiers and relative identifiers.</p>
<p>Absolute identifiers are resolved to files using the js.io path.  Given a js.io path of ['jsio/', 'lib/'], the following module identifiers might resolve to the following paths.</p>
<table>
<thead>
<tr>
<th>absolute module identifier</th>
<th>path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>net.env</code></td>
<td><code>jsio/net/env.js</code></td>
</tr>
<tr>
<td><code>timestep.View</code></td>
<td><code>lib/timestep/View.js</code></td>
</tr>
</tbody>
</table>
<p>In the example above, the identifier <code>net.env</code> was found in the <code>jsio/</code> folder.  However, <code>timestep.View</code> was not found in <code>jsio/</code>, so the module system checked <code>lib/</code> and found the import there.  (This behavior is similar to the PATH environment variable on most operating systems).<br />
</p>
<p>The default path contains the location of <code>jsio.js</code>.  We can modify the path by using the <code>jsio.path</code> object:</p>
<div class="codehilite"><pre><ol>
	<li>jsio.path.get(); // -&gt; ['jsio/']</li>
	<li>jsio.path.add('lib/');</li>
	<li>jsio.path.get(); // -&gt; ['jsio/', 'lib/']</li>
</ol></pre></div>


<p><span class="comment">Quiz: What path would the module identifier <code>.foo..bar</code> resolve to? <button onclick="document.getElementById('quizAnswer1').style.display='block'">answer</button><span id="quizAnswer1" style="display: none">
    <code>./bar.js</code>
</span></span></p>
<p>A leading dot indicates a relative path.  Consecutive dots indicate the parent directory. </p>
<table>
<thead>
<tr>
<th>module identifier</th>
<th>path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.ui.View</code></td>
<td><code>./ui/View.js</code></td>
</tr>
<tr>
<td><code>.index</code></td>
<td><code>./index.js</code></td>
</tr>
<tr>
<td><code>..foo</code></td>
<td><code>../foo.js</code></td>
</tr>
<tr>
<td><code>...foo</code></td>
<td><code>../../foo.js</code></td>
</tr>
</tbody>
</table>
<h2 id="utility">Utility</h2>
<p>The default packages in js.io are designed for writing production-quality, enterprise-class web applications.  To aid with structuring logic in JavaScript, js.io provides several built-in functions for each module.<br />
</p>
<h3 id="class">Class</h3>
<p>JavaScript supports object-oriented inheritance and code-reuse through prototypes.  Programmers are typically familiar with the structural benefits associated with a concept of 'classes', so we bridge the gap between native JavaScript inheritance and a more common view of inheritance with classes by using a helper function, <code>Class</code>.  <code>Class</code> supports the following syntax:</p>
<div class="codehilite"><pre><ol>
	<li>// returns class constructor with no parent</li>
	<li>var View = Class(viewClassDefinition);</li>
	<li></li>
	<li>// returns class constructor that inherits from View</li>
	<li>var Label = Class(View, labelClassDefinition);</li>
	<li></li>
	<li>// instantiate a Label</li>
	<li>var myLabel = new Label();</li>
	<li></li>
	<li>assert(myLabel instanceof Label &amp;&amp; myLabel instanceof View);</li>
</ol></pre></div>


<p>What are <code>viewClassDefinition</code> and <code>labelClassDefinition</code>?  These are <em>functions</em> that represent the class definitions.  For instance:</p>
<div class="codehilite"><pre><ol>
	<li>var viewClassDefinition = function() {</li>
	<li>&nbsp; &nbsp; this.init = function() {}</li>
	<li>&nbsp; &nbsp; this.show = function() {}</li>
	<li>}</li>
</ol></pre></div>


<p>In the example above, we've defined a class with two functions: <code>init</code> and <code>show</code>.  <code>init</code> is special -- it's called to initialize an instance object when <code>new View()</code> is called.  If you know how prototypes work in JavaScript, the <code>this</code> object in the viewClassDefinition refers to the prototype for the <code>View</code> class.</p>
<p>We normally don't define the class definitions in variables.  Let's look at how we might actually implement a <code>View</code> and <code>Label</code> class:</p>
<div class="codehilite"><pre><ol>
	<li>// first define the parent class.&nbsp; it's going to</li>
	<li>// create a DOM node and assign it to 'this._el'.</li>
	<li></li>
	<li>var View = Class(function() {</li>
	<li></li>
	<li>&nbsp; &nbsp; // here we define our class methods</li>
	<li></li>
	<li>&nbsp; &nbsp; this.init = function() { // constructor</li>
	<li></li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; // inside a method, 'this' refers to an instance</li>
	<li></li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; this._el = document.createElement('div');</li>
	<li>&nbsp; &nbsp; }</li>
	<li></li>
	<li>&nbsp; &nbsp; this.show = function() {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; document.body.appendChild(this._el);</li>
	<li>&nbsp; &nbsp; }</li>
	<li>});</li>
	<li></li>
	<li>// now we define a child class.&nbsp; notice the</li>
	<li>// class definition function takes one argument</li>
	<li>// called supr, which provides access to the </li>
	<li>// parent class when overriding methods</li>
	<li></li>
	<li>var Label = Class(View, function(supr) { </li>
	<li>&nbsp; &nbsp; this.init = function(text) {</li>
	<li></li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; // first, call the super class init so that an element is created</li>
	<li></li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; supr(this, 'init');</li>
	<li></li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; // then, set the text of the element</li>
	<li></li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; this.setText(text);</li>
	<li>&nbsp; &nbsp; }</li>
	<li></li>
	<li>&nbsp; &nbsp; this.setText = function(text) {</li>
	<li>&nbsp; &nbsp; &nbsp; &nbsp; this._el.innerText = text;</li>
	<li>&nbsp; &nbsp; }</li>
	<li>});</li>
	<li></li>
	<li>new Label('Hello World!').show();</li>
</ol></pre></div>


<p></div>
</div>
</span></p>